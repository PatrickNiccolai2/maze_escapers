#!/usr/bin/env python
#The line above is important so that this file is interpreted with Python when running it.

# Import of python modules.
import math # use of pi.
import tf

# import of relevant libraries.
import rospy # module for ROS APIs

from maze_escapers.srv import Neighbors, NeighborsResponse
from maze_escapers.srv import AddToMap, AddToMapResponse
from maze_escapers.srv import ExplorerBid, ExplorerBidResponse

from maze_escapers.maze_reader import MazeReader


class SharedMap():
    def __init__(self):
        self.get_whole_graph()
        self.known_vertices = []
        self.known_edges = []
        self.init_neighbors_service()
        self.init_add_to_map_service()

        # Probably need to do something better for this
        self.robot_names = ["/robot_0"]

    '''
    Use maze_reader.py to generate a graph of a given maze image, specified
    in filename
    self.whole_graph_vertices is a list of the coords of vertices for the whole maze
    self.whole_graph_edges is a list of the edges between those vertices 
    '''
    def get_whole_graph(self):
        filename = "/root/catkin_ws/src/maze_escapers/medmaze2.png"
        maze_reader = MazeReader(filename)
        self.whole_graph_vertices, self.whole_graph_edges = maze_reader.get_graph_representation()
        print("Vertices")
        print(self.whole_graph_vertices)
        print("Edges")
        print(self.whole_graph_edges)

        # Init frontier as empty list
        self.frontier = []

    '''
    Called when a robot discovers a new vertex. Add the vertices connected to
    that vertex that have not already been discovered to the frontier
    '''
    def update_frontier(self, new_vertex):
        neighbors = self.get_neighbors(new_vertex)

        for neighbor in neighbors:
            if(neighbor not in self.known_vertices and neighbor not in self.frontier):
                self.frontier.append(neighbor)

        print("new frontier")
        print(self.frontier)

        self.start_patrick_auction()

    '''
    Get the neighbors of a given vertex, looking at the whole maze
    '''
    def get_neighbors(self, vertex):
        neighbors = []

        for edge in self.whole_graph_edges:
            if(edge[0] == vertex):
                neighbors.append(edge[1])
            elif(edge[1] == vertex):
                neighbors.append(edge[0])

        return neighbors

    ############################## AUCTION ##############################

    def start_patrick_auction(self):
        print("In auction")

        for robot_name in self.robot_names:
            # For each robot, reate proxy for that robots service
            bid_server = robot_name + "/bid_service"
            rospy.wait_for_service(bid_server)
            print("After wait for bid service")
            bid_proxy = rospy.ServiceProxy(bid_server, ExplorerBid)
            for frontier_node in self.frontier:
                resp = bid_proxy(x=frontier_node[0], y=frontier_node[1])
                bid = resp.bid 
                print(bid)


    ############################## SERVICES ##############################

    '''
    init service that robots use to get the neighbors of a given vertex
    '''
    def init_neighbors_service(self):
        s = rospy.Service('/neighbor_service', Neighbors, self.handle_neighbors_service_request)
        print("neighbor_service server ready")

    '''
    Return list of neighbors of given vertex
    '''
    def handle_neighbors_service_request(self, req):
        print("in handle_neighbors_service_request, req = " + str(req))
        vertex = [req.x, req.y]
        resp_arr = []

        if(vertex in self.known_vertices):
            for edge in self.whole_graph_edges:
                if(edge[0] == vertex):
                    resp_arr.append(edge[1][0])
                    resp_arr.append(edge[1][1])
                elif(edge[1] == vertex):
                    resp_arr.append(edge[0][0])
                    resp_arr.append(edge[0][1])

        resp = NeighborsResponse()
        resp.neighbors = resp_arr
        return resp

    '''
    init service robots use to add a vertex they discovered to the shared map
    '''
    def init_add_to_map_service(self):
        s = rospy.Service('/add_to_map_service', AddToMap, self.handle_add_to_map_service_request)
        print("add_to_map_service server ready")

    '''
    Add vertex and its edges to the shared map.
    Return 1 if the vertex was not already discovered, return -1 if the vertex
    was already discovered
    '''
    def handle_add_to_map_service_request(self, req):
        print("in handle_add_to_map_service_request, x = " + str(req))
        vertex = [req.x, req.y]

        if(vertex not in self.known_vertices):
            # Remove vertex from frontier
            try:
                self.frontier.remove(vertex)
            except:
                pass

            # Update the frontier 
            self.update_frontier(vertex)

            # Add vertex to known_vertices
            self.known_vertices.append(vertex)

            # Add the vertex's edges to known_edges
            for edge in self.whole_graph_edges:
                if(edge[0] == vertex or edge[1] == 1):
                    if(edge not in self.known_edges):
                        self.known_edges.append(edge)

            return 1
        else:
            return -1 


def main():
    """Main function."""

    # 1st. initialization of node.
    rospy.init_node("shared_map")

    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    sharedmap = SharedMap()

    # Robot moves 1 m forward, rotate of 180 degrees, and moves 1 m forward.
    try:
        rospy.spin()
    except rospy.ROSInterruptException:
        rospy.logerr("ROS node interrupted.")


if __name__ == "__main__":
    """Run the main function."""
    main()
