#!/usr/bin/env python
#The line above is important so that this file is interpreted with Python when running it.

# Import of python modules.
import math # use of pi.
import tf

# import of relevant libraries.
import rospy # module for ROS APIs
from geometry_msgs.msg import Twist # message type for cmd_vel
from geometry_msgs.msg import PoseWithCovarianceStamped
from sensor_msgs.msg import LaserScan # message type for scan
from nav_msgs.msg import Odometry
from maze_escapers.srv import Neighbors, NeighborsResponse
from maze_escapers.srv import AddToMap, AddToMapResponse
from maze_escapers.srv import ExplorerBid, ExplorerBidResponse
from maze_escapers.srv import Assignment, AssignmentResponse

# Constants.
FREQUENCY = 10 #Hz.
LINEAR_VELOCITY = 0.2 # m/s
ANGULAR_VELOCITY = math.pi/4 # rad/s
LASER_ANGLE_FRONT = 0 # radians
MIN_THRESHOLD_DISTANCE = 0.5 # m, threshold distance.
DEFAULT_CMD_VEL_TOPIC = 'cmd_vel'
DEFAULT_SCAN_TOPIC = 'scan'

class Explorer():
    def __init__(self):
        self.my_name = rospy.get_namespace()

        self.start_coord = [1,1]

        # Subscribe to my odom
        rospy.Subscriber(self.my_name + "odom", Odometry, self.my_odom_callback)
        rospy.sleep(2)

        print("before wait")
        rospy.wait_for_service("/add_to_map_service")
        print("after wait")

        self.init_auction_service()
        self.init_assignment_service()

        if(self.my_name == "/robot_0/"):
            add_proxy = rospy.ServiceProxy("/add_to_map_service", AddToMap)
            resp = add_proxy(1,1)

        #resp = add_proxy(1,3)
        #print(resp)

    ############################## AUCTION SERVICE ##############################

    def init_auction_service(self):
        s = rospy.Service(self.my_name + 'bid_service', ExplorerBid, self.handle_bid)
        print("bid_service server ready")

    def handle_bid(self, req):
        print("In handle_bid, req = " + str(req))
        my_coord = [self.my_position.position.x, self.my_position.position.y]
        print(my_coord)
        req_coord = [req.x, req.y]

        my_dist = self.manhattan_distance_coords(my_coord, req_coord)
        point_to_start_dist = self.manhattan_distance_coords(self.start_coord, req_coord)

        my_bid = my_dist + point_to_start_dist
        return ExplorerBidResponse(bid=my_bid)

    ############################## ASSIGNMENT SERVICE ##############################

    def init_assignment_service(self):
        s = rospy.Service(self.my_name + "assignment_service", Assignment, self.handle_assignment)
        print("assignment_service server ready")

    def handle_assignment(self, req):
        print("in handle_assignment, req = " + str(req))
        return AssignmentResponse(response=1)

    ############################## UTILITY FUNCTIONS ##############################

    '''
    Get my position from odom and save it
    '''
    def my_odom_callback(self, msg):
        #print("in my_pose_callback")
        self.my_position = msg.pose.pose

    '''
    Calculates euclidian distance of two pairs of coords
    '''
    def euclidian_distance_coords(self, coord1, coord2):
        dist = math.sqrt((coord1[0] - coord2[0]) * (coord1[0] - coord2[0]) + (coord1[1] - coord2[1]) * (coord1[1] - coord2[1]))
        return dist

    '''
    Calculates manhattan distance of two pairs of coords
    '''
    def manhattan_distance_coords(self, coord1, coord2):
        dist = math.sqrt(abs(coord1[0] - coord2[0]) + abs(coord1[1] - coord2[1]))
        return dist



def main():
    """Main function."""

    # 1st. initialization of node.
    rospy.init_node("explorer")

    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    explorer = Explorer()

    # Robot moves 1 m forward, rotate of 180 degrees, and moves 1 m forward.
    try:
        rospy.spin()
    except rospy.ROSInterruptException:
        rospy.logerr("ROS node interrupted.")


if __name__ == "__main__":
    """Run the main function."""
    main()
