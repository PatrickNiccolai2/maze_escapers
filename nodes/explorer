#!/usr/bin/env python
#The line above is important so that this file is interpreted with Python when running it.

# Import of python modules.
import math # use of pi.
import tf
from collections import deque

# import of relevant libraries.
import rospy # module for ROS APIs
from geometry_msgs.msg import Twist # message type for cmd_vel
from geometry_msgs.msg import PoseWithCovarianceStamped
from sensor_msgs.msg import LaserScan # message type for scan
from nav_msgs.msg import Odometry
from maze_escapers.srv import Neighbors, NeighborsResponse
from maze_escapers.srv import AddToMap, AddToMapResponse
from maze_escapers.srv import ExplorerBid, ExplorerBidResponse
from maze_escapers.srv import Assignment, AssignmentResponse
from maze_escapers.srv import Ready, ReadyResponse

# Constants.
FREQUENCY = 10 #Hz.
LINEAR_VELOCITY = 0.2 # m/s
ANGULAR_VELOCITY = math.pi/4 # rad/s
LASER_ANGLE_FRONT = 0 # radians
MIN_THRESHOLD_DISTANCE = 0.5 # m, threshold distance.
DEFAULT_CMD_VEL_TOPIC = 'cmd_vel'
DEFAULT_SCAN_TOPIC = 'scan'

class Explorer():
    def __init__(self):
        self.my_name = rospy.get_namespace()
        self.my_num = int(self.my_name[7:-1])
        self.goal_coord = None
        self.old_goal = None 
        print(self.my_num)

        self._cmd_pub = rospy.Publisher(self.my_name + "cmd_vel", Twist, queue_size=1)

        self.start_coord = [1,1]

        # Subscribe to my odom
        rospy.Subscriber(self.my_name + "odom", Odometry, self.my_odom_callback)
        rospy.sleep(2)

        print("before wait")
        rospy.wait_for_service("/add_to_map_service")
        print("after wait")

        self.init_auction_service()
        self.init_assignment_service()

        # For testing
        if(self.my_name == "/robot_0/"):
            add_proxy = rospy.ServiceProxy("/add_to_map_service", AddToMap)
            resp = add_proxy(1,1)

        self.send_ready()
        #resp = add_proxy(1,3)
        #print(resp)

    ############################## AUCTION SERVICE ##############################

    '''
    This service is used to receive a vertex from shared_map and then send
    back my bid for that vertex
    '''
    def init_auction_service(self):
        s = rospy.Service(self.my_name + 'bid_service', ExplorerBid, self.handle_bid)
        print("bid_service server ready")

    def handle_bid(self, req):
        print("In handle_bid, req = " + str(req))
        my_coord = [self.my_position.position.x, self.my_position.position.y]
        print(my_coord)
        req_coord = [req.x, req.y]

        my_dist = self.manhattan_distance_coords(my_coord, req_coord)
        point_to_start_dist = self.manhattan_distance_coords(self.start_coord, req_coord)

        my_bid = my_dist + point_to_start_dist
        return ExplorerBidResponse(bid=my_bid)

    ############################## ASSIGNMENT SERVICE ##############################

    '''
    This service is used to receive my assignment from shared_map
    '''
    def init_assignment_service(self):
        s = rospy.Service(self.my_name + "assignment_service", Assignment, self.handle_assignment)
        print("assignment_service server ready")

    def handle_assignment(self, req):
        print("in handle_assignment, req = " + str(req))
        self.goal_coord = [req.x, req.y]
        return AssignmentResponse(response=1)


    ############################## MOVEMENT ##############################

    '''
    Calculates rotation and distance needed to move robot to goal
    '''
    def go_to_coord(self, goal_coord):
        my_coord = [self.my_position.position.x, self.my_position.position.y]
        print("my_coord = " + str(my_coord))
        print("goal_coord = " + str(goal_coord))
        quaternion = [self.my_position.orientation.x, self.my_position.orientation.y, self.my_position.orientation.z, self.my_position.orientation.w]
        (roll, pitch, yaw) = tf.transformations.euler_from_quaternion(quaternion)
        my_direction = yaw
        print("my_direction = " + str(my_direction))

        vector_to_goal = [goal_coord[0] - self.my_position.position.x, goal_coord[1] - self.my_position.position.y]
        direction_to_goal = math.atan2(vector_to_goal[1], vector_to_goal[0])
        print("direction_to_goal = " + str(direction_to_goal))

        rotate_angle = direction_to_goal - my_direction

        distance = self.euclidian_distance_coords(goal_coord, my_coord)

        print("rotate_angle = " + str(rotate_angle))
        self.rotate_in_place(rotate_angle)
        self.move_forward(distance)

    '''
    Rotate in place given angle
    '''
    def rotate_in_place(self, rotation_angle):
        twist_msg = Twist()
        if(rotation_angle > 0):
            twist_msg.angular.z = ANGULAR_VELOCITY
        else:
            twist_msg.angular.z = -ANGULAR_VELOCITY
        
        duration = abs(rotation_angle / twist_msg.angular.z)
        start_time = rospy.get_rostime()
        rate = rospy.Rate(FREQUENCY)
        while not rospy.is_shutdown():
            # Check if done
            if rospy.get_rostime() - start_time >= rospy.Duration(duration):
                break
                
            # Publish message.
            self._cmd_pub.publish(twist_msg)
            
            # Sleep to keep the set frequency.
            rate.sleep()

        # Rotated the required angle, stop.
        self.stop()

    '''
    Move forward given distance
    '''
    def move_forward(self, distance):
        # Rate at which to operate the while loop.
        rate = rospy.Rate(FREQUENCY)

        # Setting velocities. 
        twist_msg = Twist()
        twist_msg.linear.x = LINEAR_VELOCITY
        start_time = rospy.get_rostime()
        duration = rospy.Duration(distance/twist_msg.linear.x)

        # Loop.
        while not rospy.is_shutdown():
            # Check if traveled of given distance based on time.
            if rospy.get_rostime() - start_time >= duration:
                break

            self._cmd_pub.publish(twist_msg)

            # Sleep to keep the set publishing frequency.
            rate.sleep()

        # Traveled the required distance, stop.
        self.stop()

    def stop(self):
        """Stop the robot."""
        twist_msg = Twist()
        self._cmd_pub.publish(twist_msg)
        

    ############################## UTILITY FUNCTIONS ##############################

    '''
    Tell shared_map that I am ready to be assigned a new vertex
    '''
    def send_ready(self):
        ready_server = "/ready_service"
        rospy.wait_for_service(ready_server)
        ready_proxy = rospy.ServiceProxy(ready_server, Ready)

        resp = ready_proxy(robot_num=self.my_num)

    '''
    Get my position from odom and save it
    '''
    def my_odom_callback(self, msg):
        #print("in my_pose_callback")
        self.my_position = msg.pose.pose

        # Check if got a new goal
        if(self.goal_coord != None):
            if(self.old_goal != self.goal_coord):
                self.old_goal = self.goal_coord
                self.go_to_coord(self.goal_coord)

    '''
    Calculates euclidian distance of two pairs of coords
    '''
    def euclidian_distance_coords(self, coord1, coord2):
        dist = math.sqrt((coord1[0] - coord2[0]) * (coord1[0] - coord2[0]) + (coord1[1] - coord2[1]) * (coord1[1] - coord2[1]))
        return dist

    '''
    Calculates manhattan distance of two pairs of coords
    '''
    def manhattan_distance_coords(self, coord1, coord2):
        dist = math.sqrt(abs(coord1[0] - coord2[0]) + abs(coord1[1] - coord2[1]))
        return dist


def main():
    """Main function."""

    # 1st. initialization of node.
    rospy.init_node("explorer")

    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    explorer = Explorer()

    # Robot moves 1 m forward, rotate of 180 degrees, and moves 1 m forward.
    try:
        rospy.spin()
    except rospy.ROSInterruptException:
        rospy.logerr("ROS node interrupted.")


if __name__ == "__main__":
    """Run the main function."""
    main()
